diff --git a/src/user/device/vsd/vsd.cpp b/src/user/device/vsd/vsd.cpp
index 8c08c1d..2b15765 100644
--- a/src/user/device/vsd/vsd.cpp
+++ b/src/user/device/vsd/vsd.cpp
@@ -618,6 +618,11 @@ bool Vsd::checkStop()
   return 0;
 }
 
+bool Vsd::checkFreq()
+{
+  return false;
+}
+
 float Vsd::checkAlarmVsd()
 {
   return 0;
diff --git a/src/user/device/vsd/vsd.h b/src/user/device/vsd/vsd.h
index 3e2e617..c9635c9 100644
--- a/src/user/device/vsd/vsd.h
+++ b/src/user/device/vsd/vsd.h
@@ -433,6 +433,12 @@ public:
    */
   virtual bool checkStop();
 
+  /*!
+   * \brief Метод проверки что выходная частота равна частоте уставки
+   * \return
+   */
+  virtual bool checkFreq();
+
   virtual int resetBlock();
 
   virtual float checkAlarmVsd();
diff --git a/src/user/device/vsd/vsd_danfoss/vsd_danfoss.cpp b/src/user/device/vsd/vsd_danfoss/vsd_danfoss.cpp
index 9bcb8c3..7849f75 100644
--- a/src/user/device/vsd/vsd_danfoss/vsd_danfoss.cpp
+++ b/src/user/device/vsd/vsd_danfoss/vsd_danfoss.cpp
@@ -1167,6 +1167,13 @@ bool VsdDanfoss::checkStop()
   return false;
 }
 
+bool VsdDanfoss::checkFreq()
+{
+  if(checkBit(getvalue(VSD_STATUS_WORF_1), VSD_DANFOSS_STATUS_SPEED))
+    return true;
+  return false;
+}
+
 /*
 void VsdDanfoss::processingRegimeRun()
 {
diff --git a/src/user/device/vsd/vsd_danfoss/vsd_danfoss.h b/src/user/device/vsd/vsd_danfoss/vsd_danfoss.h
index 85c45b5..1176eb3 100644
--- a/src/user/device/vsd/vsd_danfoss/vsd_danfoss.h
+++ b/src/user/device/vsd/vsd_danfoss/vsd_danfoss.h
@@ -202,6 +202,7 @@ public:
 
   bool checkStart();
   bool checkStop();
+  bool checkFreq();
 
   int resetSetpoints();
   //void processingRegimeRun();
diff --git a/src/user/regime/regime_main.h b/src/user/regime/regime_main.h
index 365bf54..bc0bfa7 100644
--- a/src/user/regime/regime_main.h
+++ b/src/user/regime/regime_main.h
@@ -5,6 +5,7 @@
 #include "regime_technolog_soft_change_freq.h"
 #include "regime_technolog_maintenance_param.h"
 #include "regime_technolog_alternation_freq.h"
+#include "regime_technolog_jarring.h"
 
 /*!
  * \brief Функция инициализации задачи обработки всех режимов
diff --git a/src/user/regime/technolog/regime_technolog_jarring.cpp b/src/user/regime/technolog/regime_technolog_jarring.cpp
index db43f0d..dbdc176 100644
--- a/src/user/regime/technolog/regime_technolog_jarring.cpp
+++ b/src/user/regime/technolog/regime_technolog_jarring.cpp
@@ -23,5 +23,60 @@ void RegimeTechnologJarring::processing()
 
   // Получение текущих параметров режима
   state_ = parameters.get(CCS_RGM_JARRING_STATE);
+  beginTime_ = parameters.get(CCS_RGM_JARRING_TIMER);
+
+  if (action_ == offAction) {
+    state_ = IdleState;
+  }
+
+  switch (state_) {
+  case IdleState:                           // Состояние Idle
+    if (action_ != OffAction) {             // Режим включен
+      if (((parameters.get(CCS_CONDITION) == CCS_CONDITION_RUNNING) ||
+           (parameters.get(CCS_CONDITION) == CCS_CONDITION_RUN)) &&
+          ksu.isAutoMode()) {               // Мы в работе
+        beginTime_ = ksu.getTime();         // Запоминаем время перехода в работу
+        state = RunningState;               // Переходим в состояние отсчёта периода встряхивания
+#if (USE_LOG_DEBUG == 1)
+        logDebug.add((DebugMsg, "Встряхив.: запуск таймера периода встряхивания");
+#endif
+      }
+    }
+    break;
+  case RunningState:                        // Состояние отсчёта периода встряхивания
+    if (ksu.isWorkMotor() && ksu.isAutoMode()) {
+      uint32_t time = ksu.getSecFromCurTime(beginTime_);
+      if ((time > periodJar_) && periodJar_) {
+        state_ = WorkState;
+      }
+    }
+    else {
+      state = IdleState;
+#if (USE_LOG_DEBUG == 1)
+      logDebug.add(DebugMsg, "Встряхив.: выключение режима в ожидании");
+#endif
+    }
+    break;
+  case WorkState:
+    if (ksu.isWorkMotor() && ksu.isAutoMode()) {
+      // Задать темп
+      // Задать частоту
+      state_ = WorkState + 1;
+    }
+    else {
+      state = IdleState;
+#if (USE_LOG_DEBUG == 1)
+      logDebug.add(DebugMsg, "Встряхив.: выключение режима в работе ");
+#endif
+    }
+    break;
+  case WorkState + 1:
+
+    break;
+  case WorkState + 2:
+
+    break;
+  case WorkState + 3:
+  }
 }
 
